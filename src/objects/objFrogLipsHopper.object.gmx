<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprFrogLipsStand</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objEnemyParent2</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hopAlarm = irandom_range (150, 300);
alarm[1] = hopAlarm;

image_speed = 0.16;
itemDrop = choose (obj5Gem);
randomize();
initHpoints = 20;
attackDamage = 1;
hpoints = initHpoints;
canHit = true;
isHit = false;
ground = true;
enableguard = false;
guarding = false;
vel = 0;
yvel = 0;
yfr = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if itemDrop != 0
   instance_create (x, y, itemDrop);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hopAlarm = irandom_range (180, 300);
alarm[1] = hopAlarm;

image_index = 0;
sprite_index = sprFrogLipsJump;

if instance_exists (objPlayer)
{
    if x &gt; objPlayer.x
    {
       vel = -3;
       image_xscale = 1;
    }
    else
    {
        vel = 3;
        image_xscale = -1;
    }
}

ground = false;
yvel = -9;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collision with a wall
//Allows the player to collide with walls

//Floor
var myWall = instance_place(x, y+yvel+1, objSolid2);
if myWall &gt;= 0 &amp;&amp; yvel &gt; 0
{
    y = myWall.y - (sprite_get_height(sprite_index) - sprite_get_yoffset(sprite_index));
    ground = true;
    yvel = 0;

    //Note: there used to be a system here that set MM's sprite to the walking sprite when landing
    //However, due to complications such as climbing up ladders, it was a lot of work for such a minor feature
    //Therefore, it has been removed
}


//Wall
myWall = instance_place(x+vel, y, objSolid2);
if myWall &gt;= 0 &amp;&amp; vel != 0
{
    if vel &lt; 0
    {
        x = myWall.bbox_right + sprite_get_xoffset(sprite_index) - sprite_get_bbox_left(sprite_index);
        
        //For some reason, the code above would work correctly half the time, but clip MM inside the wall the other half
        //This while-loop fixes the issue by forcing MM out of the wall
        while place_meeting(x, y, myWall)
            x += 1;
    }
    else
        x = myWall.x - (sprite_get_width(sprite_index) - sprite_get_xoffset(sprite_index)) + (sprite_get_width(sprite_index) - sprite_get_bbox_right(sprite_index)) - 1;
        
    vel = 0;
}


//Ceiling
myWall = instance_place(x, y+yvel, objSolid2);
if myWall &gt;= 0 &amp;&amp; yvel &lt; 0
{
    y = myWall.bbox_bottom + sprite_get_yoffset(sprite_index);
    
    //For some reason, the code above would work correctly half the time, but clip MM inside the ceiling the other half
    //This while-loop fixes the issue by forcing MM out of the ceiling
    while place_meeting(x, y, myWall)
        y += 1;
        
    yvel = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (place_meeting (x, y+yvel+1, objSolid2) or place_meeting (x, y+yvel+1, objTopSolid)) &amp;&amp; yvel &gt;= 0
{
   ground = true;
   yfr = 0;
   vel = 0;
   sprite_index = sprFrogLipsStand;
}
else
{
    ground = false;
    yfr = 0.25;
    sprite_index = sprFrogLipsJump;
}

if place_meeting (x, y+yvel-1, objSolid2) &amp;&amp; yvel &lt;= 0
{
    ground = false;
    yvel = 0;
}

if yvel &gt; 10
   yvel = 10;
   
if sprite_index = sprFrogLipsJump &amp;&amp; image_index &gt; 5
   image_index = 2;
   
x += vel;
y += yvel;

if !ground
    yvel += yfr;
    
/*if (place_meeting (x+vel+1, y, objWall)) or x &gt; instance_nearest (x, y, objWall).x
    x -= 1;
if (place_meeting (x+vel-1, y, objWall)) or x &lt; instance_nearest (x, y, objWall).x
    x += 1;
if (place_meeting (x, y+yvel+1, objWall)) or y &gt; instance_nearest (x, y, objWall).y
    y -= 1;
if (place_meeting (x, y+yvel-1, objWall)) or y &lt; instance_nearest (x, y, objWall).y
    y += 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objTopSolid">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scrCollideSlopes2();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if hpoints &lt; initHpoints
{
    draw_set_font (fntFont);
    scrDrawOutlines (x, y-50, hpoints, c_black, c_white, 2);
}

draw_sprite_ext (sprite_index, image_index, round(x), round(y), image_xscale, image_yscale, image_angle, image_blend, image_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
